<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module unid_srv</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module unid_srv</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul><b>Problem</b>


<h2><a name="description">Description</a></h2><p><b>Problem</b></p>

 <p>Imagine you are building a system to assign unique numbers to each resource that 
you manage. You want the ids to be guaranteed unique i.e. no UUIDs. 
Since these ids are globally unique, each id can only be given out at most once. 
The ids are 64 bits long.</p>

 <p>Your service is composed of a set of nodes, each running one process serving ids.
 A caller will connect to one of the nodes and ask it for a globally unique id.
 There are a fixed number of nodes in the system, up to 1024.  Each node has a numeric id,
 0 &lt;= id &lt;= 1023. Each node knows its id at startup and that id never changes for the node.</p>

 <p>The task is to implement get_id.  When a caller requests a new id, the node it connects 
to calls its internal get_id function to get a new, globally unique id.</p>

 Assume that any node will not receive more than 100,000 requests per second.
 <hr>
 First of all let separate ids generated by different nodes. We need ten bits for representing
 numbers in the range 0 &lt;= node_id &lt;= 1023. So ids will be represented as
 <pre> id = node_id*2**(64-10) + rest; where 0 &lt;= rest &lt; 2**54 </pre>
 So for each node_id its id range is
 <pre> [node_id*2**54, (node_id+1)*2**54) ([ , ) is semi interval.)</pre><p> 
and the ranges do not overlap.</p>

 To guarantee that after the application restarts ids will be unique
 we divide <i>rest</i> into two parts:
 <pre>rest = seconds*2**(54-32) + cntr; where 0 &lt;= cntr &lt; 2**22 </pre><p> 
For the same reason id ranges corresponding to different seconds do not overlap.</p>

 node_id is a fixed number, but seconds changes in two cases:
 <ol>
 <li> applications starts or restarts</li>
 <li> cntr value reaches maximum value 2**22-1</li>
 </ol>
 To calculate new seconds value erlang:system_time(seconds) is called.
 This may cause different problems
 <ul>
 <li> erlang:system_time is monotonic function in all latest implementations, but it is not
 strictly monotonic. But one second interval is large enough and the function will be called
 only during restart or after 83.9 seconds in case of 100000 calls per second rate, so
 there is no chances that erlang:system_time will return the same value twice.
 </li>
 <li> 32 bits unsigned integer will be eventually repeated. Original UNIX used 32 singed
 bits integer to store seconds.
 One second after 03:14:07 UTC 2038-01-19 this representation will overflow.
 On 64 bit boxes Erlang uses 64 bits signed integer to overcome this problem.
 For this reason I added conversion seconds to least significant 32 bits.
 Taken into account that maximum  singed integer is 2147483647 and there is 86400
 seconds in UNIX day, application will work correctly for next 68 years.
 </li>
 <li>Solution depends on NTP service. If the application is moved to another box with
 no NTP service or malfunctioning NTP service then application may repeats ids.
 </li>
 </ul>
 <hr>
 Please write answers to the following discussion questions and
 include them in your solution as comments:
 <ol>
 <li><p> 
Please describe your solution to get_id and why it is correct i.e. guaranteed globally unique.</p>

 <p>This was explained in details already.</p>

 </li>
 <li><p> 
Please explain how your solution achieves the desired performance i.e. 100,000 or more requests per second per node. 
How did you verify this?</p>

 <p>Almost all calls required only one fast arithmetics operation - adding 1, and modifying record in one 
standard Erlang call back. Only one of 8388607 calls requires calling one extra function mk_base 
which contains four basic arithmetics operations and declared inline.</p>

 <p>Real performance can't be tested until request mechanism is specified. 
(Is it rpc call, HTTP request, tcp or upd connection.) From my experience this will be the 
most time consuming part.</p>

 </li>
 <li>
 Please enumerate possible failure cases and describe how your solution correctly handles each case.
 How did you verify correctness?
 Some example cases:
 <ol>
 <li><p> 
How do you manage uniqueness after a node crashes and restarts?</p>

 <p>This was explained in details already.</p>

 </li>
 <li><p> 
How do you manage uniqueness after the entire system fails and restarts?</p>

 <p>The entire system contains of interdependent nodes which can be restarted 
independently.</p>

 </li>
 <li><p> 
How do you handle software defects?</p>

 <p>Possible software problems are already discussed.</p>

 <p>I also wrote some simple unitest cases. They are really basic, but while
 working on them I found bug in Erlang/OTP:
 <a href="https://bugs.erlang.org/browse/ERL-1308">ERL-1308</a>.</p>

 </li>
 </ol>
 </li>
 </ol>
 <hr>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-s_t">s_t()</a></h3>
<p><tt>s_t() = #s_t{node_id = non_neg_integer(), base = non_neg_integer(), cntr = non_neg_integer()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#get_id-0">get_id/0</a></td><td>Returns unique id.</td></tr>
<tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#info-0">info/0</a></td><td>Returns information about current state.</td></tr>
<tr><td valign="top"><a href="#init-1">init/1</a></td><td>Initiates  unid_srv.</td></tr>
<tr><td valign="top"><a href="#mk_base-2">mk_base/2</a></td><td>Creates base for id calculation.</td></tr>
<tr><td valign="top"><a href="#node_id-0">node_id/0</a></td><td>Returns node id.</td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Starts unid_srv.</td></tr>
<tr><td valign="top"><a href="#timestamp-0">timestamp/0</a></td><td>Returns time stamp since the epoch in milliseconds.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="get_id-0">get_id/0</a></h3>
<div class="spec">
<p><tt>get_id() -&gt; non_neg_integer()</tt><br></p>
</div><p>Returns unique id</p>

<h3 class="function"><a name="handle_call-3">handle_call/3</a></h3>
<div class="spec">
<p><tt>handle_call(X1, From, ST) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="handle_cast-2">handle_cast/2</a></h3>
<div class="spec">
<p><tt>handle_cast(X1, ST) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="info-0">info/0</a></h3>
<div class="spec">
<p><tt>info() -&gt; <a href="#type-s_t">s_t()</a></tt><br></p>
</div><p>Returns information about current state</p>

<h3 class="function"><a name="init-1">init/1</a></h3>
<div class="spec">
<p><tt>init(X1::{non_neg_integer()}) -&gt; {ok, <a href="#type-s_t">s_t()</a>}</tt><br></p>
</div><p>Initiates  unid_srv.</p>

<h3 class="function"><a name="mk_base-2">mk_base/2</a></h3>
<div class="spec">
<p><tt>mk_base(NodeId::non_neg_integer(), Seconds::non_neg_integer()) -&gt; non_neg_integer()</tt><br></p>
</div><p>Creates base for id calculation</p>

<h3 class="function"><a name="node_id-0">node_id/0</a></h3>
<div class="spec">
<p><tt>node_id() -&gt; non_neg_integer()</tt><br></p>
</div><p>Returns node id</p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(NodeId::non_neg_integer()) -&gt; {ok, pid()}</tt><br></p>
</div><p>Starts unid_srv.</p>

<h3 class="function"><a name="timestamp-0">timestamp/0</a></h3>
<div class="spec">
<p><tt>timestamp() -&gt; non_neg_integer()</tt><br></p>
</div><p>Returns time stamp since the epoch in milliseconds.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
